{"version":3,"sources":["webpack:///./src/$_lazy_route_resource lazy namespace object","webpack:///./src/app/app-routing.module.ts","webpack:///./src/app/app.component.css","webpack:///./src/app/app.component.html","webpack:///./src/app/app.component.ts","webpack:///./src/app/app.module.ts","webpack:///./src/app/chat/chat.component.css","webpack:///./src/app/chat/chat.component.html","webpack:///./src/app/chat/chat.component.ts","webpack:///./src/app/login.service.ts","webpack:///./src/app/login/login.component.css","webpack:///./src/app/login/login.component.html","webpack:///./src/app/login/login.component.ts","webpack:///./src/app/protocol/Protocol.js","webpack:///./src/app/signup/signup.component.css","webpack:///./src/app/signup/signup.component.html","webpack:///./src/app/signup/signup.component.ts","webpack:///./src/app/websocket.service.ts","webpack:///./src/environments/environment.ts","webpack:///./src/main.ts"],"names":[],"mappings":"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sB,YAAY;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,8EAA8E,4CAA4C;AAC1H;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gGAAgG,4CAA4C;AAC5I;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,OAAO;AAC1B,qBAAqB,wBAAwB;AAC7C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,qBAAqB,wBAAwB;AAC7C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,mBAAmB,6BAA6B;AAChD,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB,OAAO;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC,sBAAsB,YAAY;AAClC,sBAAsB,iBAAiB;AACvC,sBAAsB,YAAY;AAClC,sBAAsB,iBAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,qCAAqC;AAC5G;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAyF,qCAAqC;AAC9H;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,OAAO;AAC1B,qBAAqB,iBAAiB;AACtC,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,qBAAqB,iBAAiB;AACtC,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,6BAA6B;AAChD,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,2CAA2C;AACjE,sBAAsB,iBAAiB;AACvC,sBAAsB,qCAAqC;AAC3D,sBAAsB,YAAY;AAClC,sBAAsB,YAAY;AAClC,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC,sBAAsB,YAAY;AAClC,sBAAsB,+BAA+B;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,6CAA6C;AAC5H;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;;AAEA;AACA,iGAAiG,6CAA6C;AAC9I;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,OAAO;AAC1B,qBAAqB,yBAAyB;AAC9C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,qBAAqB,yBAAyB;AAC9C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,mBAAmB,6BAA6B;AAChD,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,2EAA2E,yCAAyC;AACpH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6FAA6F,yCAAyC;AACtI;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,OAAO;AAC1B,qBAAqB,qBAAqB;AAC1C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,qBAAqB,qBAAqB;AAC1C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,6BAA6B;AAChD,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,4EAA4E,0CAA0C;AACtH;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8FAA8F,0CAA0C;AACxI;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C,mBAAmB,iBAAiB;AACpC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,OAAO;AAC1B,qBAAqB,sBAAsB;AAC3C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,qBAAqB,sBAAsB;AAC3C,oBAAoB,MAAM;AAC1B,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,6BAA6B;AAChD,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAC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","file":"main.js","sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./src/$$_lazy_route_resource lazy recursive\";","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { LoginComponent } from './login/login.component';\nimport { ChatComponent } from './chat/chat.component';\nimport { SignupComponent } from './signup/signup.component';\nconst routes: Routes = [\n  {path: \"login\",component:LoginComponent},\n  {path: \"chat\",component:ChatComponent},\n  {path: \"signup\",component:SignupComponent}\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n","module.exports = \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2FwcC5jb21wb25lbnQuY3NzIn0= */\"","module.exports = \"\\n\\n<h1>Message System v1</h1>\\n<nav>\\n  <div>\\n  <a routerLink=\\\"/login\\\" routerLinkActive=\\\"active\\\" nz-button nzType=\\\"primary\\\" [nzBlock]=50>登录</a>\\n</div>\\n<div>\\n  <a routerLink=\\\"/signup\\\" routerLinkActive=\\\"active\\\" nz-button nzType=\\\"primary\\\" [nzBlock]=50>注册</a>\\n</div>\\n<div>\\n  <a routerLink=\\\"/chat\\\" routerLinkActive=\\\"active\\\" nz-button nzType=\\\"primary\\\" [nzBlock]=50>|聊天|</a>\\n</div>\\n</nav>\\n<br>\\n<br>\\n<router-outlet></router-outlet>\\n\"","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'WStest';\n}\n","import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { LoginComponent } from './login/login.component';\n\nimport {WebsocketService  } from './websocket.service';\nimport {LoginService  } from './login.service';\nimport { ChatComponent } from './chat/chat.component';\nimport { SignupComponent } from './signup/signup.component';\nimport { NgZorroAntdModule, NZ_I18N, en_US } from 'ng-zorro-antd';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { registerLocaleData } from '@angular/common';\nimport en from '@angular/common/locales/en';\n\nregisterLocaleData(en);\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    LoginComponent,\n    ChatComponent,\n    SignupComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    FormsModule,\n    NgZorroAntdModule,\n    BrowserAnimationsModule\n  ],\n  providers: [WebsocketService,WebsocketService,LoginService, { provide: NZ_I18N, useValue: en_US }],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n","module.exports = \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2NoYXQvY2hhdC5jb21wb25lbnQuY3NzIn0= */\"","module.exports = \"<p>\\n  <button nz-button nzType=\\\"primary\\\" (click)=\\\"sendMsg()\\\">SEND</button>\\n  <button nz-button nzType=\\\"primary\\\" (click)=\\\"sendMsg()\\\">TEST</button>\\n\\n</p>\\n\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"发送给：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"to_id\\\">\\n  </nz-input-group>\\n</div>\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"内容：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"content\\\">\\n  </nz-input-group>\\n</div>\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"我的ID：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"from_id\\\">\\n  </nz-input-group>\\n</div>\\n<button nz-button nzType=\\\"primary\\\" (click)=\\\"sendMsg()\\\">SEND</button>\\n\\n\\n\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"发送给组：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"group\\\">\\n  </nz-input-group>\\n</div>\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"内容：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"content\\\">\\n  </nz-input-group>\\n</div>\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"我的ID：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"from_id\\\">\\n  </nz-input-group>\\n</div>\\n<button nz-button nzType=\\\"primary\\\" (click)=\\\"sendToGoup()\\\">SEND</button>\\n\\n\\n\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"发送给组：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"addgtoup_id\\\">\\n  </nz-input-group>\\n</div>\\n<div style=\\\"margin-bottom: 16px;\\\">\\n  <nz-input-group nzAddOnBefore=\\\"我的ID：\\\" >\\n    <input type=\\\"text\\\" nz-input [(ngModel)]=\\\"from_id\\\">\\n  </nz-input-group>\\n</div>\\n<button nz-button nzType=\\\"primary\\\" (click)=\\\"addGoup()\\\">SEND</button>\\n\"","import { Component, OnInit } from '@angular/core';\nimport {WebsocketService  } from '../websocket.service';\nimport { Protocol } from '../protocol/Protocol';\n\n\n\n\n@Component({\n  selector: 'app-chat',\n  templateUrl: './chat.component.html',\n  styleUrls: ['./chat.component.css']\n})\nexport class ChatComponent implements OnInit {\n  \n\n  from_id = 0;\n  to_id = 0;\n  group =0;\n  addgtoup_id=0;\n  content=\"\";\n  constructor(private ws:WebsocketService) { \n   \n  }\n\n  ngOnInit() {\n    this.ws.createSocket(\"ws://localhost:9876/ws\");\n   \n  }\n\n\n  sendMsg() {\n    console.log(\"had send message\");\n    let msg = new(Protocol.MessageRequest)\n    msg.from = this.from_id;\n    msg.to  = this.to_id;\n    msg.content = this.content;\n    msg.TypeOfMsg = Protocol.MessageRequest.RequestType.C2CSEND_REQUEST\n    this.ws.sendMessage(Protocol.MessageRequest.encode(msg).finish())\n  }\n\n  sendToGoup() {\n    console.log(\"had send message\");\n    let msg = new(Protocol.MessageRequest)\n    msg.from = this.from_id;\n    msg.group  = this.group;\n    msg.content = this.content;\n    msg.TypeOfMsg = Protocol.MessageRequest.RequestType.C2GSEND_REQUEST\n    this.ws.sendMessage(Protocol.MessageRequest.encode(msg).finish())\n  }\n\n  addGoup() {\n    console.log(\"had send message\");\n    let msg = new(Protocol.MessageRequest)\n    msg.from = this.from_id;\n    msg.group  = this.addgtoup_id;\n    msg.TypeOfMsg = Protocol.MessageRequest.RequestType.CONTROL_REQUEST;\n    msg.TypeOfCtrl = Protocol.MessageRequest.CtrlType.GROUP_ADDMEMBERS;\n    this.ws.sendMessage(Protocol.MessageRequest.encode(msg).finish())\n  }\n  test(){\n    let msg = new(Protocol.MessageResponse)\n    msg.content = \"testing websocket protocol buf\"\n    msg.msgid = 28;\n    console.log(Protocol.MessageRequest.encode(msg).finish())\n  }\n  \n}\n\n","import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable()\nexport class LoginService {\n  constructor(private http: HttpClient) { }\n\n  configUrl = 'http://localhost:9876/api';\n  loginUrl = this.configUrl+\"/login\"\n  signupUrl = this.configUrl+'/signup'\n  postLoginData(data) {\n    return this.http.post(this.loginUrl, data);\n  }\n  postSignupData(data) {\n    return this.http.post(this.signupUrl, data);\n  }\n}\n","module.exports = \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2xvZ2luL2xvZ2luLmNvbXBvbmVudC5jc3MifQ== */\"","module.exports = \"\\n<div style=\\\"margin-left:100px\\\">\\n    <h1>登录</h1>\\n    <div>.</div>\\n  Username:<input nz-input placeholder=\\\"default size\\\" [(ngModel)]=\\\"name\\\" style=\\\"width: 200px\\\">\\n  <div>.</div>\\n  Password:<input nz-input placeholder=\\\"default size\\\" [(ngModel)]=\\\"password\\\" style=\\\"width: 200px\\\">\\n  <div>.</div>\\n  <button (click)=\\\"submit()\\\" nz-button nzType=\\\"primary\\\">提交</button>\\n</div>\\n\\n\"","import { Component, OnInit } from '@angular/core';\nimport { LoginService  } from '../login.service';\n\n@Component({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent implements OnInit {\n\n  constructor(private login: LoginService) { }\n\n  ngOnInit() {\n  }\n  name =''\n  password = ''\n\n  submit(){\n      let body = {name:this.name,password:this.password}\n      this.login.postLoginData(body).subscribe(data =>{\n        console.log(data);\n      })\n  }\n}\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.Protocol = (function() {\n\n    /**\n     * Namespace Protocol.\n     * @exports Protocol\n     * @namespace\n     */\n    var Protocol = {};\n\n    Protocol.MessageRequest = (function() {\n\n        /**\n         * Properties of a MessageRequest.\n         * @memberof Protocol\n         * @interface IMessageRequest\n         * @property {Protocol.MessageRequest.RequestType|null} [TypeOfMsg] MessageRequest TypeOfMsg\n         * @property {number|Long|null} [from] MessageRequest from\n         * @property {number|Long|null} [to] MessageRequest to\n         * @property {number|Long|null} [group] MessageRequest group\n         * @property {string|null} [content] MessageRequest content\n         * @property {number|Long|null} [uid] MessageRequest uid\n         * @property {number|Long|null} [msgid] MessageRequest msgid\n         * @property {string|null} [token] MessageRequest token\n         * @property {number|Long|null} [timestamp] MessageRequest timestamp\n         * @property {Protocol.MessageRequest.CtrlType|null} [TypeOfCtrl] MessageRequest TypeOfCtrl\n         * @property {Protocol.MessageRequest.Reasion|null} [reasion] MessageRequest reasion\n         * @property {number|Long|null} [offset] MessageRequest offset\n         * @property {number|null} [limit] MessageRequest limit\n         */\n\n        /**\n         * Constructs a new MessageRequest.\n         * @memberof Protocol\n         * @classdesc Represents a MessageRequest.\n         * @implements IMessageRequest\n         * @constructor\n         * @param {Protocol.IMessageRequest=} [properties] Properties to set\n         */\n        function MessageRequest(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MessageRequest TypeOfMsg.\n         * @member {Protocol.MessageRequest.RequestType} TypeOfMsg\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.TypeOfMsg = 0;\n\n        /**\n         * MessageRequest from.\n         * @member {number|Long} from\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.from = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest to.\n         * @member {number|Long} to\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.to = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest group.\n         * @member {number|Long} group\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.group = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest content.\n         * @member {string} content\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.content = \"\";\n\n        /**\n         * MessageRequest uid.\n         * @member {number|Long} uid\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest msgid.\n         * @member {number|Long} msgid\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.msgid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest token.\n         * @member {string} token\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.token = \"\";\n\n        /**\n         * MessageRequest timestamp.\n         * @member {number|Long} timestamp\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest TypeOfCtrl.\n         * @member {Protocol.MessageRequest.CtrlType} TypeOfCtrl\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.TypeOfCtrl = 0;\n\n        /**\n         * MessageRequest reasion.\n         * @member {Protocol.MessageRequest.Reasion} reasion\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.reasion = 0;\n\n        /**\n         * MessageRequest offset.\n         * @member {number|Long} offset\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageRequest limit.\n         * @member {number} limit\n         * @memberof Protocol.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.limit = 0;\n\n        /**\n         * Creates a new MessageRequest instance using the specified properties.\n         * @function create\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {Protocol.IMessageRequest=} [properties] Properties to set\n         * @returns {Protocol.MessageRequest} MessageRequest instance\n         */\n        MessageRequest.create = function create(properties) {\n            return new MessageRequest(properties);\n        };\n\n        /**\n         * Encodes the specified MessageRequest message. Does not implicitly {@link Protocol.MessageRequest.verify|verify} messages.\n         * @function encode\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {Protocol.IMessageRequest} message MessageRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageRequest.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.TypeOfMsg != null && message.hasOwnProperty(\"TypeOfMsg\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TypeOfMsg);\n            if (message.from != null && message.hasOwnProperty(\"from\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.from);\n            if (message.to != null && message.hasOwnProperty(\"to\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.to);\n            if (message.group != null && message.hasOwnProperty(\"group\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.group);\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.content);\n            if (message.uid != null && message.hasOwnProperty(\"uid\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.uid);\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.msgid);\n            if (message.token != null && message.hasOwnProperty(\"token\"))\n                writer.uint32(/* id 8, wireType 2 =*/66).string(message.token);\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timestamp);\n            if (message.TypeOfCtrl != null && message.hasOwnProperty(\"TypeOfCtrl\"))\n                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.TypeOfCtrl);\n            if (message.reasion != null && message.hasOwnProperty(\"reasion\"))\n                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.reasion);\n            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.offset);\n            if (message.limit != null && message.hasOwnProperty(\"limit\"))\n                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.limit);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified MessageRequest message, length delimited. Does not implicitly {@link Protocol.MessageRequest.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {Protocol.IMessageRequest} message MessageRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageRequest.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a MessageRequest message from the specified reader or buffer.\n         * @function decode\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Protocol.MessageRequest} MessageRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRequest.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.MessageRequest();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.TypeOfMsg = reader.int32();\n                    break;\n                case 2:\n                    message.from = reader.int64();\n                    break;\n                case 3:\n                    message.to = reader.int64();\n                    break;\n                case 4:\n                    message.group = reader.int64();\n                    break;\n                case 5:\n                    message.content = reader.string();\n                    break;\n                case 6:\n                    message.uid = reader.int64();\n                    break;\n                case 7:\n                    message.msgid = reader.int64();\n                    break;\n                case 8:\n                    message.token = reader.string();\n                    break;\n                case 9:\n                    message.timestamp = reader.int64();\n                    break;\n                case 10:\n                    message.TypeOfCtrl = reader.int32();\n                    break;\n                case 11:\n                    message.reasion = reader.int32();\n                    break;\n                case 12:\n                    message.offset = reader.int64();\n                    break;\n                case 13:\n                    message.limit = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a MessageRequest message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Protocol.MessageRequest} MessageRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRequest.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a MessageRequest message.\n         * @function verify\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        MessageRequest.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.TypeOfMsg != null && message.hasOwnProperty(\"TypeOfMsg\"))\n                switch (message.TypeOfMsg) {\n                default:\n                    return \"TypeOfMsg: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                    break;\n                }\n            if (message.from != null && message.hasOwnProperty(\"from\"))\n                if (!$util.isInteger(message.from) && !(message.from && $util.isInteger(message.from.low) && $util.isInteger(message.from.high)))\n                    return \"from: integer|Long expected\";\n            if (message.to != null && message.hasOwnProperty(\"to\"))\n                if (!$util.isInteger(message.to) && !(message.to && $util.isInteger(message.to.low) && $util.isInteger(message.to.high)))\n                    return \"to: integer|Long expected\";\n            if (message.group != null && message.hasOwnProperty(\"group\"))\n                if (!$util.isInteger(message.group) && !(message.group && $util.isInteger(message.group.low) && $util.isInteger(message.group.high)))\n                    return \"group: integer|Long expected\";\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                if (!$util.isString(message.content))\n                    return \"content: string expected\";\n            if (message.uid != null && message.hasOwnProperty(\"uid\"))\n                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))\n                    return \"uid: integer|Long expected\";\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (!$util.isInteger(message.msgid) && !(message.msgid && $util.isInteger(message.msgid.low) && $util.isInteger(message.msgid.high)))\n                    return \"msgid: integer|Long expected\";\n            if (message.token != null && message.hasOwnProperty(\"token\"))\n                if (!$util.isString(message.token))\n                    return \"token: string expected\";\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))\n                    return \"timestamp: integer|Long expected\";\n            if (message.TypeOfCtrl != null && message.hasOwnProperty(\"TypeOfCtrl\"))\n                switch (message.TypeOfCtrl) {\n                default:\n                    return \"TypeOfCtrl: enum value expected\";\n                case 0:\n                case 1:\n                case 3:\n                case 4:\n                case 5:\n                    break;\n                }\n            if (message.reasion != null && message.hasOwnProperty(\"reasion\"))\n                switch (message.reasion) {\n                default:\n                    return \"reasion: enum value expected\";\n                case 0:\n                    break;\n                }\n            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                    return \"offset: integer|Long expected\";\n            if (message.limit != null && message.hasOwnProperty(\"limit\"))\n                if (!$util.isInteger(message.limit))\n                    return \"limit: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a MessageRequest message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Protocol.MessageRequest} MessageRequest\n         */\n        MessageRequest.fromObject = function fromObject(object) {\n            if (object instanceof $root.Protocol.MessageRequest)\n                return object;\n            var message = new $root.Protocol.MessageRequest();\n            switch (object.TypeOfMsg) {\n            case \"AUTH_REQUEST\":\n            case 0:\n                message.TypeOfMsg = 0;\n                break;\n            case \"C2CSEND_REQUEST\":\n            case 1:\n                message.TypeOfMsg = 1;\n                break;\n            case \"C2CPUSH_REQUEST\":\n            case 2:\n                message.TypeOfMsg = 2;\n                break;\n            case \"C2GSEND_REQUEST\":\n            case 3:\n                message.TypeOfMsg = 3;\n                break;\n            case \"C2GPUSH_REQUEST\":\n            case 4:\n                message.TypeOfMsg = 4;\n                break;\n            case \"CtrlSEND_REQUEST\":\n            case 5:\n                message.TypeOfMsg = 5;\n                break;\n            case \"CtrPUSH_REQUEST\":\n            case 6:\n                message.TypeOfMsg = 6;\n                break;\n            case \"KICKOUT_REQUEST\":\n            case 7:\n                message.TypeOfMsg = 7;\n                break;\n            case \"PULL_REQUEST\":\n            case 8:\n                message.TypeOfMsg = 8;\n                break;\n            case \"CONTROL_REQUEST\":\n            case 9:\n                message.TypeOfMsg = 9;\n                break;\n            }\n            if (object.from != null)\n                if ($util.Long)\n                    (message.from = $util.Long.fromValue(object.from)).unsigned = false;\n                else if (typeof object.from === \"string\")\n                    message.from = parseInt(object.from, 10);\n                else if (typeof object.from === \"number\")\n                    message.from = object.from;\n                else if (typeof object.from === \"object\")\n                    message.from = new $util.LongBits(object.from.low >>> 0, object.from.high >>> 0).toNumber();\n            if (object.to != null)\n                if ($util.Long)\n                    (message.to = $util.Long.fromValue(object.to)).unsigned = false;\n                else if (typeof object.to === \"string\")\n                    message.to = parseInt(object.to, 10);\n                else if (typeof object.to === \"number\")\n                    message.to = object.to;\n                else if (typeof object.to === \"object\")\n                    message.to = new $util.LongBits(object.to.low >>> 0, object.to.high >>> 0).toNumber();\n            if (object.group != null)\n                if ($util.Long)\n                    (message.group = $util.Long.fromValue(object.group)).unsigned = false;\n                else if (typeof object.group === \"string\")\n                    message.group = parseInt(object.group, 10);\n                else if (typeof object.group === \"number\")\n                    message.group = object.group;\n                else if (typeof object.group === \"object\")\n                    message.group = new $util.LongBits(object.group.low >>> 0, object.group.high >>> 0).toNumber();\n            if (object.content != null)\n                message.content = String(object.content);\n            if (object.uid != null)\n                if ($util.Long)\n                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;\n                else if (typeof object.uid === \"string\")\n                    message.uid = parseInt(object.uid, 10);\n                else if (typeof object.uid === \"number\")\n                    message.uid = object.uid;\n                else if (typeof object.uid === \"object\")\n                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();\n            if (object.msgid != null)\n                if ($util.Long)\n                    (message.msgid = $util.Long.fromValue(object.msgid)).unsigned = false;\n                else if (typeof object.msgid === \"string\")\n                    message.msgid = parseInt(object.msgid, 10);\n                else if (typeof object.msgid === \"number\")\n                    message.msgid = object.msgid;\n                else if (typeof object.msgid === \"object\")\n                    message.msgid = new $util.LongBits(object.msgid.low >>> 0, object.msgid.high >>> 0).toNumber();\n            if (object.token != null)\n                message.token = String(object.token);\n            if (object.timestamp != null)\n                if ($util.Long)\n                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;\n                else if (typeof object.timestamp === \"string\")\n                    message.timestamp = parseInt(object.timestamp, 10);\n                else if (typeof object.timestamp === \"number\")\n                    message.timestamp = object.timestamp;\n                else if (typeof object.timestamp === \"object\")\n                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();\n            switch (object.TypeOfCtrl) {\n            case \"CREATE_GROUP\":\n            case 0:\n                message.TypeOfCtrl = 0;\n                break;\n            case \"GROUP_ADDMEMBERS\":\n            case 1:\n                message.TypeOfCtrl = 1;\n                break;\n            case \"GROUP_EXIT\":\n            case 3:\n                message.TypeOfCtrl = 3;\n                break;\n            case \"GROUP_DELETE\":\n            case 4:\n                message.TypeOfCtrl = 4;\n                break;\n            case \"MSG_BACK\":\n            case 5:\n                message.TypeOfCtrl = 5;\n                break;\n            }\n            switch (object.reasion) {\n            case \"OTHER_LOGIN\":\n            case 0:\n                message.reasion = 0;\n                break;\n            }\n            if (object.offset != null)\n                if ($util.Long)\n                    (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;\n                else if (typeof object.offset === \"string\")\n                    message.offset = parseInt(object.offset, 10);\n                else if (typeof object.offset === \"number\")\n                    message.offset = object.offset;\n                else if (typeof object.offset === \"object\")\n                    message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();\n            if (object.limit != null)\n                message.limit = object.limit | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a MessageRequest message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Protocol.MessageRequest\n         * @static\n         * @param {Protocol.MessageRequest} message MessageRequest\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        MessageRequest.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.TypeOfMsg = options.enums === String ? \"AUTH_REQUEST\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.from = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.from = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.to = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.to = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.group = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.group = options.longs === String ? \"0\" : 0;\n                object.content = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.uid = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.msgid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.msgid = options.longs === String ? \"0\" : 0;\n                object.token = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.timestamp = options.longs === String ? \"0\" : 0;\n                object.TypeOfCtrl = options.enums === String ? \"CREATE_GROUP\" : 0;\n                object.reasion = options.enums === String ? \"OTHER_LOGIN\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.offset = options.longs === String ? \"0\" : 0;\n                object.limit = 0;\n            }\n            if (message.TypeOfMsg != null && message.hasOwnProperty(\"TypeOfMsg\"))\n                object.TypeOfMsg = options.enums === String ? $root.Protocol.MessageRequest.RequestType[message.TypeOfMsg] : message.TypeOfMsg;\n            if (message.from != null && message.hasOwnProperty(\"from\"))\n                if (typeof message.from === \"number\")\n                    object.from = options.longs === String ? String(message.from) : message.from;\n                else\n                    object.from = options.longs === String ? $util.Long.prototype.toString.call(message.from) : options.longs === Number ? new $util.LongBits(message.from.low >>> 0, message.from.high >>> 0).toNumber() : message.from;\n            if (message.to != null && message.hasOwnProperty(\"to\"))\n                if (typeof message.to === \"number\")\n                    object.to = options.longs === String ? String(message.to) : message.to;\n                else\n                    object.to = options.longs === String ? $util.Long.prototype.toString.call(message.to) : options.longs === Number ? new $util.LongBits(message.to.low >>> 0, message.to.high >>> 0).toNumber() : message.to;\n            if (message.group != null && message.hasOwnProperty(\"group\"))\n                if (typeof message.group === \"number\")\n                    object.group = options.longs === String ? String(message.group) : message.group;\n                else\n                    object.group = options.longs === String ? $util.Long.prototype.toString.call(message.group) : options.longs === Number ? new $util.LongBits(message.group.low >>> 0, message.group.high >>> 0).toNumber() : message.group;\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                object.content = message.content;\n            if (message.uid != null && message.hasOwnProperty(\"uid\"))\n                if (typeof message.uid === \"number\")\n                    object.uid = options.longs === String ? String(message.uid) : message.uid;\n                else\n                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (typeof message.msgid === \"number\")\n                    object.msgid = options.longs === String ? String(message.msgid) : message.msgid;\n                else\n                    object.msgid = options.longs === String ? $util.Long.prototype.toString.call(message.msgid) : options.longs === Number ? new $util.LongBits(message.msgid.low >>> 0, message.msgid.high >>> 0).toNumber() : message.msgid;\n            if (message.token != null && message.hasOwnProperty(\"token\"))\n                object.token = message.token;\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (typeof message.timestamp === \"number\")\n                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;\n                else\n                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;\n            if (message.TypeOfCtrl != null && message.hasOwnProperty(\"TypeOfCtrl\"))\n                object.TypeOfCtrl = options.enums === String ? $root.Protocol.MessageRequest.CtrlType[message.TypeOfCtrl] : message.TypeOfCtrl;\n            if (message.reasion != null && message.hasOwnProperty(\"reasion\"))\n                object.reasion = options.enums === String ? $root.Protocol.MessageRequest.Reasion[message.reasion] : message.reasion;\n            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                if (typeof message.offset === \"number\")\n                    object.offset = options.longs === String ? String(message.offset) : message.offset;\n                else\n                    object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;\n            if (message.limit != null && message.hasOwnProperty(\"limit\"))\n                object.limit = message.limit;\n            return object;\n        };\n\n        /**\n         * Converts this MessageRequest to JSON.\n         * @function toJSON\n         * @memberof Protocol.MessageRequest\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        MessageRequest.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * RequestType enum.\n         * @name Protocol.MessageRequest.RequestType\n         * @enum {string}\n         * @property {number} AUTH_REQUEST=0 AUTH_REQUEST value\n         * @property {number} C2CSEND_REQUEST=1 C2CSEND_REQUEST value\n         * @property {number} C2CPUSH_REQUEST=2 C2CPUSH_REQUEST value\n         * @property {number} C2GSEND_REQUEST=3 C2GSEND_REQUEST value\n         * @property {number} C2GPUSH_REQUEST=4 C2GPUSH_REQUEST value\n         * @property {number} CtrlSEND_REQUEST=5 CtrlSEND_REQUEST value\n         * @property {number} CtrPUSH_REQUEST=6 CtrPUSH_REQUEST value\n         * @property {number} KICKOUT_REQUEST=7 KICKOUT_REQUEST value\n         * @property {number} PULL_REQUEST=8 PULL_REQUEST value\n         * @property {number} CONTROL_REQUEST=9 CONTROL_REQUEST value\n         */\n        MessageRequest.RequestType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"AUTH_REQUEST\"] = 0;\n            values[valuesById[1] = \"C2CSEND_REQUEST\"] = 1;\n            values[valuesById[2] = \"C2CPUSH_REQUEST\"] = 2;\n            values[valuesById[3] = \"C2GSEND_REQUEST\"] = 3;\n            values[valuesById[4] = \"C2GPUSH_REQUEST\"] = 4;\n            values[valuesById[5] = \"CtrlSEND_REQUEST\"] = 5;\n            values[valuesById[6] = \"CtrPUSH_REQUEST\"] = 6;\n            values[valuesById[7] = \"KICKOUT_REQUEST\"] = 7;\n            values[valuesById[8] = \"PULL_REQUEST\"] = 8;\n            values[valuesById[9] = \"CONTROL_REQUEST\"] = 9;\n            return values;\n        })();\n\n        /**\n         * CtrlType enum.\n         * @name Protocol.MessageRequest.CtrlType\n         * @enum {string}\n         * @property {number} CREATE_GROUP=0 CREATE_GROUP value\n         * @property {number} GROUP_ADDMEMBERS=1 GROUP_ADDMEMBERS value\n         * @property {number} GROUP_EXIT=3 GROUP_EXIT value\n         * @property {number} GROUP_DELETE=4 GROUP_DELETE value\n         * @property {number} MSG_BACK=5 MSG_BACK value\n         */\n        MessageRequest.CtrlType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"CREATE_GROUP\"] = 0;\n            values[valuesById[1] = \"GROUP_ADDMEMBERS\"] = 1;\n            values[valuesById[3] = \"GROUP_EXIT\"] = 3;\n            values[valuesById[4] = \"GROUP_DELETE\"] = 4;\n            values[valuesById[5] = \"MSG_BACK\"] = 5;\n            return values;\n        })();\n\n        /**\n         * Reasion enum.\n         * @name Protocol.MessageRequest.Reasion\n         * @enum {string}\n         * @property {number} OTHER_LOGIN=0 OTHER_LOGIN value\n         */\n        MessageRequest.Reasion = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"OTHER_LOGIN\"] = 0;\n            return values;\n        })();\n\n        return MessageRequest;\n    })();\n\n    Protocol.PullMsg = (function() {\n\n        /**\n         * Properties of a PullMsg.\n         * @memberof Protocol\n         * @interface IPullMsg\n         * @property {number|Long|null} [from] PullMsg from\n         * @property {number|Long|null} [to] PullMsg to\n         * @property {number|Long|null} [group] PullMsg group\n         * @property {string|null} [content] PullMsg content\n         * @property {number|Long|null} [msgid] PullMsg msgid\n         * @property {number|null} [cmdid] PullMsg cmdid\n         * @property {number|Long|null} [sendTime] PullMsg sendTime\n         */\n\n        /**\n         * Constructs a new PullMsg.\n         * @memberof Protocol\n         * @classdesc Represents a PullMsg.\n         * @implements IPullMsg\n         * @constructor\n         * @param {Protocol.IPullMsg=} [properties] Properties to set\n         */\n        function PullMsg(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PullMsg from.\n         * @member {number|Long} from\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.from = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * PullMsg to.\n         * @member {number|Long} to\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.to = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * PullMsg group.\n         * @member {number|Long} group\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.group = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * PullMsg content.\n         * @member {string} content\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.content = \"\";\n\n        /**\n         * PullMsg msgid.\n         * @member {number|Long} msgid\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.msgid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * PullMsg cmdid.\n         * @member {number} cmdid\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.cmdid = 0;\n\n        /**\n         * PullMsg sendTime.\n         * @member {number|Long} sendTime\n         * @memberof Protocol.PullMsg\n         * @instance\n         */\n        PullMsg.prototype.sendTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * Creates a new PullMsg instance using the specified properties.\n         * @function create\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {Protocol.IPullMsg=} [properties] Properties to set\n         * @returns {Protocol.PullMsg} PullMsg instance\n         */\n        PullMsg.create = function create(properties) {\n            return new PullMsg(properties);\n        };\n\n        /**\n         * Encodes the specified PullMsg message. Does not implicitly {@link Protocol.PullMsg.verify|verify} messages.\n         * @function encode\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {Protocol.IPullMsg} message PullMsg message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PullMsg.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.from != null && message.hasOwnProperty(\"from\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.from);\n            if (message.to != null && message.hasOwnProperty(\"to\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.to);\n            if (message.group != null && message.hasOwnProperty(\"group\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.group);\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.content);\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.msgid);\n            if (message.cmdid != null && message.hasOwnProperty(\"cmdid\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cmdid);\n            if (message.sendTime != null && message.hasOwnProperty(\"sendTime\"))\n                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sendTime);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified PullMsg message, length delimited. Does not implicitly {@link Protocol.PullMsg.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {Protocol.IPullMsg} message PullMsg message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PullMsg.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a PullMsg message from the specified reader or buffer.\n         * @function decode\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Protocol.PullMsg} PullMsg\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PullMsg.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.PullMsg();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.from = reader.int64();\n                    break;\n                case 2:\n                    message.to = reader.int64();\n                    break;\n                case 3:\n                    message.group = reader.int64();\n                    break;\n                case 4:\n                    message.content = reader.string();\n                    break;\n                case 5:\n                    message.msgid = reader.int64();\n                    break;\n                case 6:\n                    message.cmdid = reader.int32();\n                    break;\n                case 7:\n                    message.sendTime = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a PullMsg message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Protocol.PullMsg} PullMsg\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PullMsg.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a PullMsg message.\n         * @function verify\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        PullMsg.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.from != null && message.hasOwnProperty(\"from\"))\n                if (!$util.isInteger(message.from) && !(message.from && $util.isInteger(message.from.low) && $util.isInteger(message.from.high)))\n                    return \"from: integer|Long expected\";\n            if (message.to != null && message.hasOwnProperty(\"to\"))\n                if (!$util.isInteger(message.to) && !(message.to && $util.isInteger(message.to.low) && $util.isInteger(message.to.high)))\n                    return \"to: integer|Long expected\";\n            if (message.group != null && message.hasOwnProperty(\"group\"))\n                if (!$util.isInteger(message.group) && !(message.group && $util.isInteger(message.group.low) && $util.isInteger(message.group.high)))\n                    return \"group: integer|Long expected\";\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                if (!$util.isString(message.content))\n                    return \"content: string expected\";\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (!$util.isInteger(message.msgid) && !(message.msgid && $util.isInteger(message.msgid.low) && $util.isInteger(message.msgid.high)))\n                    return \"msgid: integer|Long expected\";\n            if (message.cmdid != null && message.hasOwnProperty(\"cmdid\"))\n                if (!$util.isInteger(message.cmdid))\n                    return \"cmdid: integer expected\";\n            if (message.sendTime != null && message.hasOwnProperty(\"sendTime\"))\n                if (!$util.isInteger(message.sendTime) && !(message.sendTime && $util.isInteger(message.sendTime.low) && $util.isInteger(message.sendTime.high)))\n                    return \"sendTime: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates a PullMsg message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Protocol.PullMsg} PullMsg\n         */\n        PullMsg.fromObject = function fromObject(object) {\n            if (object instanceof $root.Protocol.PullMsg)\n                return object;\n            var message = new $root.Protocol.PullMsg();\n            if (object.from != null)\n                if ($util.Long)\n                    (message.from = $util.Long.fromValue(object.from)).unsigned = false;\n                else if (typeof object.from === \"string\")\n                    message.from = parseInt(object.from, 10);\n                else if (typeof object.from === \"number\")\n                    message.from = object.from;\n                else if (typeof object.from === \"object\")\n                    message.from = new $util.LongBits(object.from.low >>> 0, object.from.high >>> 0).toNumber();\n            if (object.to != null)\n                if ($util.Long)\n                    (message.to = $util.Long.fromValue(object.to)).unsigned = false;\n                else if (typeof object.to === \"string\")\n                    message.to = parseInt(object.to, 10);\n                else if (typeof object.to === \"number\")\n                    message.to = object.to;\n                else if (typeof object.to === \"object\")\n                    message.to = new $util.LongBits(object.to.low >>> 0, object.to.high >>> 0).toNumber();\n            if (object.group != null)\n                if ($util.Long)\n                    (message.group = $util.Long.fromValue(object.group)).unsigned = false;\n                else if (typeof object.group === \"string\")\n                    message.group = parseInt(object.group, 10);\n                else if (typeof object.group === \"number\")\n                    message.group = object.group;\n                else if (typeof object.group === \"object\")\n                    message.group = new $util.LongBits(object.group.low >>> 0, object.group.high >>> 0).toNumber();\n            if (object.content != null)\n                message.content = String(object.content);\n            if (object.msgid != null)\n                if ($util.Long)\n                    (message.msgid = $util.Long.fromValue(object.msgid)).unsigned = false;\n                else if (typeof object.msgid === \"string\")\n                    message.msgid = parseInt(object.msgid, 10);\n                else if (typeof object.msgid === \"number\")\n                    message.msgid = object.msgid;\n                else if (typeof object.msgid === \"object\")\n                    message.msgid = new $util.LongBits(object.msgid.low >>> 0, object.msgid.high >>> 0).toNumber();\n            if (object.cmdid != null)\n                message.cmdid = object.cmdid | 0;\n            if (object.sendTime != null)\n                if ($util.Long)\n                    (message.sendTime = $util.Long.fromValue(object.sendTime)).unsigned = false;\n                else if (typeof object.sendTime === \"string\")\n                    message.sendTime = parseInt(object.sendTime, 10);\n                else if (typeof object.sendTime === \"number\")\n                    message.sendTime = object.sendTime;\n                else if (typeof object.sendTime === \"object\")\n                    message.sendTime = new $util.LongBits(object.sendTime.low >>> 0, object.sendTime.high >>> 0).toNumber();\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a PullMsg message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Protocol.PullMsg\n         * @static\n         * @param {Protocol.PullMsg} message PullMsg\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        PullMsg.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.from = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.from = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.to = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.to = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.group = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.group = options.longs === String ? \"0\" : 0;\n                object.content = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.msgid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.msgid = options.longs === String ? \"0\" : 0;\n                object.cmdid = 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.sendTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.sendTime = options.longs === String ? \"0\" : 0;\n            }\n            if (message.from != null && message.hasOwnProperty(\"from\"))\n                if (typeof message.from === \"number\")\n                    object.from = options.longs === String ? String(message.from) : message.from;\n                else\n                    object.from = options.longs === String ? $util.Long.prototype.toString.call(message.from) : options.longs === Number ? new $util.LongBits(message.from.low >>> 0, message.from.high >>> 0).toNumber() : message.from;\n            if (message.to != null && message.hasOwnProperty(\"to\"))\n                if (typeof message.to === \"number\")\n                    object.to = options.longs === String ? String(message.to) : message.to;\n                else\n                    object.to = options.longs === String ? $util.Long.prototype.toString.call(message.to) : options.longs === Number ? new $util.LongBits(message.to.low >>> 0, message.to.high >>> 0).toNumber() : message.to;\n            if (message.group != null && message.hasOwnProperty(\"group\"))\n                if (typeof message.group === \"number\")\n                    object.group = options.longs === String ? String(message.group) : message.group;\n                else\n                    object.group = options.longs === String ? $util.Long.prototype.toString.call(message.group) : options.longs === Number ? new $util.LongBits(message.group.low >>> 0, message.group.high >>> 0).toNumber() : message.group;\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                object.content = message.content;\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (typeof message.msgid === \"number\")\n                    object.msgid = options.longs === String ? String(message.msgid) : message.msgid;\n                else\n                    object.msgid = options.longs === String ? $util.Long.prototype.toString.call(message.msgid) : options.longs === Number ? new $util.LongBits(message.msgid.low >>> 0, message.msgid.high >>> 0).toNumber() : message.msgid;\n            if (message.cmdid != null && message.hasOwnProperty(\"cmdid\"))\n                object.cmdid = message.cmdid;\n            if (message.sendTime != null && message.hasOwnProperty(\"sendTime\"))\n                if (typeof message.sendTime === \"number\")\n                    object.sendTime = options.longs === String ? String(message.sendTime) : message.sendTime;\n                else\n                    object.sendTime = options.longs === String ? $util.Long.prototype.toString.call(message.sendTime) : options.longs === Number ? new $util.LongBits(message.sendTime.low >>> 0, message.sendTime.high >>> 0).toNumber() : message.sendTime;\n            return object;\n        };\n\n        /**\n         * Converts this PullMsg to JSON.\n         * @function toJSON\n         * @memberof Protocol.PullMsg\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        PullMsg.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return PullMsg;\n    })();\n\n    Protocol.MessageResponse = (function() {\n\n        /**\n         * Properties of a MessageResponse.\n         * @memberof Protocol\n         * @interface IMessageResponse\n         * @property {Protocol.MessageResponse.ResponseType|null} [TypeOfResponse] MessageResponse TypeOfResponse\n         * @property {number|Long|null} [msgTo] MessageResponse msgTo\n         * @property {Protocol.MessageResponse.Status|null} [status] MessageResponse status\n         * @property {number|null} [errCode] MessageResponse errCode\n         * @property {string|null} [errMsg] MessageResponse errMsg\n         * @property {number|Long|null} [msgid] MessageResponse msgid\n         * @property {number|Long|null} [timestamp] MessageResponse timestamp\n         * @property {string|null} [content] MessageResponse content\n         * @property {Array.<Protocol.IPullMsg>|null} [msg] MessageResponse msg\n         */\n\n        /**\n         * Constructs a new MessageResponse.\n         * @memberof Protocol\n         * @classdesc Represents a MessageResponse.\n         * @implements IMessageResponse\n         * @constructor\n         * @param {Protocol.IMessageResponse=} [properties] Properties to set\n         */\n        function MessageResponse(properties) {\n            this.msg = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MessageResponse TypeOfResponse.\n         * @member {Protocol.MessageResponse.ResponseType} TypeOfResponse\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.TypeOfResponse = 0;\n\n        /**\n         * MessageResponse msgTo.\n         * @member {number|Long} msgTo\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.msgTo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageResponse status.\n         * @member {Protocol.MessageResponse.Status} status\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.status = 0;\n\n        /**\n         * MessageResponse errCode.\n         * @member {number} errCode\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.errCode = 0;\n\n        /**\n         * MessageResponse errMsg.\n         * @member {string} errMsg\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.errMsg = \"\";\n\n        /**\n         * MessageResponse msgid.\n         * @member {number|Long} msgid\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.msgid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageResponse timestamp.\n         * @member {number|Long} timestamp\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * MessageResponse content.\n         * @member {string} content\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.content = \"\";\n\n        /**\n         * MessageResponse msg.\n         * @member {Array.<Protocol.IPullMsg>} msg\n         * @memberof Protocol.MessageResponse\n         * @instance\n         */\n        MessageResponse.prototype.msg = $util.emptyArray;\n\n        /**\n         * Creates a new MessageResponse instance using the specified properties.\n         * @function create\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {Protocol.IMessageResponse=} [properties] Properties to set\n         * @returns {Protocol.MessageResponse} MessageResponse instance\n         */\n        MessageResponse.create = function create(properties) {\n            return new MessageResponse(properties);\n        };\n\n        /**\n         * Encodes the specified MessageResponse message. Does not implicitly {@link Protocol.MessageResponse.verify|verify} messages.\n         * @function encode\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {Protocol.IMessageResponse} message MessageResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageResponse.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.TypeOfResponse != null && message.hasOwnProperty(\"TypeOfResponse\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TypeOfResponse);\n            if (message.msgTo != null && message.hasOwnProperty(\"msgTo\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.msgTo);\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);\n            if (message.errCode != null && message.hasOwnProperty(\"errCode\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.errCode);\n            if (message.errMsg != null && message.hasOwnProperty(\"errMsg\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.errMsg);\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.msgid);\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                writer.uint32(/* id 8, wireType 2 =*/66).string(message.content);\n            if (message.msg != null && message.msg.length)\n                for (var i = 0; i < message.msg.length; ++i)\n                    $root.Protocol.PullMsg.encode(message.msg[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified MessageResponse message, length delimited. Does not implicitly {@link Protocol.MessageResponse.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {Protocol.IMessageResponse} message MessageResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageResponse.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a MessageResponse message from the specified reader or buffer.\n         * @function decode\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Protocol.MessageResponse} MessageResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageResponse.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.MessageResponse();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.TypeOfResponse = reader.int32();\n                    break;\n                case 2:\n                    message.msgTo = reader.int64();\n                    break;\n                case 3:\n                    message.status = reader.int32();\n                    break;\n                case 4:\n                    message.errCode = reader.int32();\n                    break;\n                case 5:\n                    message.errMsg = reader.string();\n                    break;\n                case 6:\n                    message.msgid = reader.int64();\n                    break;\n                case 7:\n                    message.timestamp = reader.int64();\n                    break;\n                case 8:\n                    message.content = reader.string();\n                    break;\n                case 9:\n                    if (!(message.msg && message.msg.length))\n                        message.msg = [];\n                    message.msg.push($root.Protocol.PullMsg.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a MessageResponse message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Protocol.MessageResponse} MessageResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageResponse.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a MessageResponse message.\n         * @function verify\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        MessageResponse.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.TypeOfResponse != null && message.hasOwnProperty(\"TypeOfResponse\"))\n                switch (message.TypeOfResponse) {\n                default:\n                    return \"TypeOfResponse: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                    break;\n                }\n            if (message.msgTo != null && message.hasOwnProperty(\"msgTo\"))\n                if (!$util.isInteger(message.msgTo) && !(message.msgTo && $util.isInteger(message.msgTo.low) && $util.isInteger(message.msgTo.high)))\n                    return \"msgTo: integer|Long expected\";\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                switch (message.status) {\n                default:\n                    return \"status: enum value expected\";\n                case 0:\n                case 1:\n                    break;\n                }\n            if (message.errCode != null && message.hasOwnProperty(\"errCode\"))\n                if (!$util.isInteger(message.errCode))\n                    return \"errCode: integer expected\";\n            if (message.errMsg != null && message.hasOwnProperty(\"errMsg\"))\n                if (!$util.isString(message.errMsg))\n                    return \"errMsg: string expected\";\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (!$util.isInteger(message.msgid) && !(message.msgid && $util.isInteger(message.msgid.low) && $util.isInteger(message.msgid.high)))\n                    return \"msgid: integer|Long expected\";\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))\n                    return \"timestamp: integer|Long expected\";\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                if (!$util.isString(message.content))\n                    return \"content: string expected\";\n            if (message.msg != null && message.hasOwnProperty(\"msg\")) {\n                if (!Array.isArray(message.msg))\n                    return \"msg: array expected\";\n                for (var i = 0; i < message.msg.length; ++i) {\n                    var error = $root.Protocol.PullMsg.verify(message.msg[i]);\n                    if (error)\n                        return \"msg.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a MessageResponse message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Protocol.MessageResponse} MessageResponse\n         */\n        MessageResponse.fromObject = function fromObject(object) {\n            if (object instanceof $root.Protocol.MessageResponse)\n                return object;\n            var message = new $root.Protocol.MessageResponse();\n            switch (object.TypeOfResponse) {\n            case \"Auth_RESPONSE\":\n            case 0:\n                message.TypeOfResponse = 0;\n                break;\n            case \"C2CSEND_RESPONSE\":\n            case 1:\n                message.TypeOfResponse = 1;\n                break;\n            case \"C2CPUSH_RESPONSE\":\n            case 2:\n                message.TypeOfResponse = 2;\n                break;\n            case \"C2GSEND_RESPONSE\":\n            case 3:\n                message.TypeOfResponse = 3;\n                break;\n            case \"C2GPUSH_RESPONSE\":\n            case 4:\n                message.TypeOfResponse = 4;\n                break;\n            case \"CtrlSEND_RESPONSE\":\n            case 5:\n                message.TypeOfResponse = 5;\n                break;\n            case \"CtrlPUSH_RESPONSE\":\n            case 6:\n                message.TypeOfResponse = 6;\n                break;\n            case \"PULL_RESPONSE\":\n            case 7:\n                message.TypeOfResponse = 7;\n                break;\n            }\n            if (object.msgTo != null)\n                if ($util.Long)\n                    (message.msgTo = $util.Long.fromValue(object.msgTo)).unsigned = false;\n                else if (typeof object.msgTo === \"string\")\n                    message.msgTo = parseInt(object.msgTo, 10);\n                else if (typeof object.msgTo === \"number\")\n                    message.msgTo = object.msgTo;\n                else if (typeof object.msgTo === \"object\")\n                    message.msgTo = new $util.LongBits(object.msgTo.low >>> 0, object.msgTo.high >>> 0).toNumber();\n            switch (object.status) {\n            case \"OK\":\n            case 0:\n                message.status = 0;\n                break;\n            case \"Err\":\n            case 1:\n                message.status = 1;\n                break;\n            }\n            if (object.errCode != null)\n                message.errCode = object.errCode | 0;\n            if (object.errMsg != null)\n                message.errMsg = String(object.errMsg);\n            if (object.msgid != null)\n                if ($util.Long)\n                    (message.msgid = $util.Long.fromValue(object.msgid)).unsigned = false;\n                else if (typeof object.msgid === \"string\")\n                    message.msgid = parseInt(object.msgid, 10);\n                else if (typeof object.msgid === \"number\")\n                    message.msgid = object.msgid;\n                else if (typeof object.msgid === \"object\")\n                    message.msgid = new $util.LongBits(object.msgid.low >>> 0, object.msgid.high >>> 0).toNumber();\n            if (object.timestamp != null)\n                if ($util.Long)\n                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;\n                else if (typeof object.timestamp === \"string\")\n                    message.timestamp = parseInt(object.timestamp, 10);\n                else if (typeof object.timestamp === \"number\")\n                    message.timestamp = object.timestamp;\n                else if (typeof object.timestamp === \"object\")\n                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();\n            if (object.content != null)\n                message.content = String(object.content);\n            if (object.msg) {\n                if (!Array.isArray(object.msg))\n                    throw TypeError(\".Protocol.MessageResponse.msg: array expected\");\n                message.msg = [];\n                for (var i = 0; i < object.msg.length; ++i) {\n                    if (typeof object.msg[i] !== \"object\")\n                        throw TypeError(\".Protocol.MessageResponse.msg: object expected\");\n                    message.msg[i] = $root.Protocol.PullMsg.fromObject(object.msg[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a MessageResponse message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Protocol.MessageResponse\n         * @static\n         * @param {Protocol.MessageResponse} message MessageResponse\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        MessageResponse.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.msg = [];\n            if (options.defaults) {\n                object.TypeOfResponse = options.enums === String ? \"Auth_RESPONSE\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.msgTo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.msgTo = options.longs === String ? \"0\" : 0;\n                object.status = options.enums === String ? \"OK\" : 0;\n                object.errCode = 0;\n                object.errMsg = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.msgid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.msgid = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.timestamp = options.longs === String ? \"0\" : 0;\n                object.content = \"\";\n            }\n            if (message.TypeOfResponse != null && message.hasOwnProperty(\"TypeOfResponse\"))\n                object.TypeOfResponse = options.enums === String ? $root.Protocol.MessageResponse.ResponseType[message.TypeOfResponse] : message.TypeOfResponse;\n            if (message.msgTo != null && message.hasOwnProperty(\"msgTo\"))\n                if (typeof message.msgTo === \"number\")\n                    object.msgTo = options.longs === String ? String(message.msgTo) : message.msgTo;\n                else\n                    object.msgTo = options.longs === String ? $util.Long.prototype.toString.call(message.msgTo) : options.longs === Number ? new $util.LongBits(message.msgTo.low >>> 0, message.msgTo.high >>> 0).toNumber() : message.msgTo;\n            if (message.status != null && message.hasOwnProperty(\"status\"))\n                object.status = options.enums === String ? $root.Protocol.MessageResponse.Status[message.status] : message.status;\n            if (message.errCode != null && message.hasOwnProperty(\"errCode\"))\n                object.errCode = message.errCode;\n            if (message.errMsg != null && message.hasOwnProperty(\"errMsg\"))\n                object.errMsg = message.errMsg;\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (typeof message.msgid === \"number\")\n                    object.msgid = options.longs === String ? String(message.msgid) : message.msgid;\n                else\n                    object.msgid = options.longs === String ? $util.Long.prototype.toString.call(message.msgid) : options.longs === Number ? new $util.LongBits(message.msgid.low >>> 0, message.msgid.high >>> 0).toNumber() : message.msgid;\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (typeof message.timestamp === \"number\")\n                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;\n                else\n                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;\n            if (message.content != null && message.hasOwnProperty(\"content\"))\n                object.content = message.content;\n            if (message.msg && message.msg.length) {\n                object.msg = [];\n                for (var j = 0; j < message.msg.length; ++j)\n                    object.msg[j] = $root.Protocol.PullMsg.toObject(message.msg[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this MessageResponse to JSON.\n         * @function toJSON\n         * @memberof Protocol.MessageResponse\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        MessageResponse.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Status enum.\n         * @name Protocol.MessageResponse.Status\n         * @enum {string}\n         * @property {number} OK=0 OK value\n         * @property {number} Err=1 Err value\n         */\n        MessageResponse.Status = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"OK\"] = 0;\n            values[valuesById[1] = \"Err\"] = 1;\n            return values;\n        })();\n\n        /**\n         * ResponseType enum.\n         * @name Protocol.MessageResponse.ResponseType\n         * @enum {string}\n         * @property {number} Auth_RESPONSE=0 Auth_RESPONSE value\n         * @property {number} C2CSEND_RESPONSE=1 C2CSEND_RESPONSE value\n         * @property {number} C2CPUSH_RESPONSE=2 C2CPUSH_RESPONSE value\n         * @property {number} C2GSEND_RESPONSE=3 C2GSEND_RESPONSE value\n         * @property {number} C2GPUSH_RESPONSE=4 C2GPUSH_RESPONSE value\n         * @property {number} CtrlSEND_RESPONSE=5 CtrlSEND_RESPONSE value\n         * @property {number} CtrlPUSH_RESPONSE=6 CtrlPUSH_RESPONSE value\n         * @property {number} PULL_RESPONSE=7 PULL_RESPONSE value\n         */\n        MessageResponse.ResponseType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"Auth_RESPONSE\"] = 0;\n            values[valuesById[1] = \"C2CSEND_RESPONSE\"] = 1;\n            values[valuesById[2] = \"C2CPUSH_RESPONSE\"] = 2;\n            values[valuesById[3] = \"C2GSEND_RESPONSE\"] = 3;\n            values[valuesById[4] = \"C2GPUSH_RESPONSE\"] = 4;\n            values[valuesById[5] = \"CtrlSEND_RESPONSE\"] = 5;\n            values[valuesById[6] = \"CtrlPUSH_RESPONSE\"] = 6;\n            values[valuesById[7] = \"PULL_RESPONSE\"] = 7;\n            return values;\n        })();\n\n        return MessageResponse;\n    })();\n\n    Protocol.ACKResponse = (function() {\n\n        /**\n         * Properties of a ACKResponse.\n         * @memberof Protocol\n         * @interface IACKResponse\n         * @property {number|Long|null} [msgid] ACKResponse msgid\n         * @property {number|Long|null} [timestamp] ACKResponse timestamp\n         */\n\n        /**\n         * Constructs a new ACKResponse.\n         * @memberof Protocol\n         * @classdesc Represents a ACKResponse.\n         * @implements IACKResponse\n         * @constructor\n         * @param {Protocol.IACKResponse=} [properties] Properties to set\n         */\n        function ACKResponse(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ACKResponse msgid.\n         * @member {number|Long} msgid\n         * @memberof Protocol.ACKResponse\n         * @instance\n         */\n        ACKResponse.prototype.msgid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * ACKResponse timestamp.\n         * @member {number|Long} timestamp\n         * @memberof Protocol.ACKResponse\n         * @instance\n         */\n        ACKResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * Creates a new ACKResponse instance using the specified properties.\n         * @function create\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {Protocol.IACKResponse=} [properties] Properties to set\n         * @returns {Protocol.ACKResponse} ACKResponse instance\n         */\n        ACKResponse.create = function create(properties) {\n            return new ACKResponse(properties);\n        };\n\n        /**\n         * Encodes the specified ACKResponse message. Does not implicitly {@link Protocol.ACKResponse.verify|verify} messages.\n         * @function encode\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {Protocol.IACKResponse} message ACKResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ACKResponse.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.msgid);\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ACKResponse message, length delimited. Does not implicitly {@link Protocol.ACKResponse.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {Protocol.IACKResponse} message ACKResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ACKResponse.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ACKResponse message from the specified reader or buffer.\n         * @function decode\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Protocol.ACKResponse} ACKResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ACKResponse.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ACKResponse();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.msgid = reader.int64();\n                    break;\n                case 2:\n                    message.timestamp = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ACKResponse message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Protocol.ACKResponse} ACKResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ACKResponse.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ACKResponse message.\n         * @function verify\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ACKResponse.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (!$util.isInteger(message.msgid) && !(message.msgid && $util.isInteger(message.msgid.low) && $util.isInteger(message.msgid.high)))\n                    return \"msgid: integer|Long expected\";\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))\n                    return \"timestamp: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ACKResponse message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Protocol.ACKResponse} ACKResponse\n         */\n        ACKResponse.fromObject = function fromObject(object) {\n            if (object instanceof $root.Protocol.ACKResponse)\n                return object;\n            var message = new $root.Protocol.ACKResponse();\n            if (object.msgid != null)\n                if ($util.Long)\n                    (message.msgid = $util.Long.fromValue(object.msgid)).unsigned = false;\n                else if (typeof object.msgid === \"string\")\n                    message.msgid = parseInt(object.msgid, 10);\n                else if (typeof object.msgid === \"number\")\n                    message.msgid = object.msgid;\n                else if (typeof object.msgid === \"object\")\n                    message.msgid = new $util.LongBits(object.msgid.low >>> 0, object.msgid.high >>> 0).toNumber();\n            if (object.timestamp != null)\n                if ($util.Long)\n                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;\n                else if (typeof object.timestamp === \"string\")\n                    message.timestamp = parseInt(object.timestamp, 10);\n                else if (typeof object.timestamp === \"number\")\n                    message.timestamp = object.timestamp;\n                else if (typeof object.timestamp === \"object\")\n                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ACKResponse message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Protocol.ACKResponse\n         * @static\n         * @param {Protocol.ACKResponse} message ACKResponse\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ACKResponse.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.msgid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.msgid = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.timestamp = options.longs === String ? \"0\" : 0;\n            }\n            if (message.msgid != null && message.hasOwnProperty(\"msgid\"))\n                if (typeof message.msgid === \"number\")\n                    object.msgid = options.longs === String ? String(message.msgid) : message.msgid;\n                else\n                    object.msgid = options.longs === String ? $util.Long.prototype.toString.call(message.msgid) : options.longs === Number ? new $util.LongBits(message.msgid.low >>> 0, message.msgid.high >>> 0).toNumber() : message.msgid;\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (typeof message.timestamp === \"number\")\n                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;\n                else\n                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;\n            return object;\n        };\n\n        /**\n         * Converts this ACKResponse to JSON.\n         * @function toJSON\n         * @memberof Protocol.ACKResponse\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ACKResponse.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ACKResponse;\n    })();\n\n    Protocol.EmptyRequest = (function() {\n\n        /**\n         * Properties of an EmptyRequest.\n         * @memberof Protocol\n         * @interface IEmptyRequest\n         */\n\n        /**\n         * Constructs a new EmptyRequest.\n         * @memberof Protocol\n         * @classdesc Represents an EmptyRequest.\n         * @implements IEmptyRequest\n         * @constructor\n         * @param {Protocol.IEmptyRequest=} [properties] Properties to set\n         */\n        function EmptyRequest(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Creates a new EmptyRequest instance using the specified properties.\n         * @function create\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {Protocol.IEmptyRequest=} [properties] Properties to set\n         * @returns {Protocol.EmptyRequest} EmptyRequest instance\n         */\n        EmptyRequest.create = function create(properties) {\n            return new EmptyRequest(properties);\n        };\n\n        /**\n         * Encodes the specified EmptyRequest message. Does not implicitly {@link Protocol.EmptyRequest.verify|verify} messages.\n         * @function encode\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {Protocol.IEmptyRequest} message EmptyRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        EmptyRequest.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified EmptyRequest message, length delimited. Does not implicitly {@link Protocol.EmptyRequest.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {Protocol.IEmptyRequest} message EmptyRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        EmptyRequest.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an EmptyRequest message from the specified reader or buffer.\n         * @function decode\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Protocol.EmptyRequest} EmptyRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        EmptyRequest.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.EmptyRequest();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an EmptyRequest message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Protocol.EmptyRequest} EmptyRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        EmptyRequest.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an EmptyRequest message.\n         * @function verify\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        EmptyRequest.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            return null;\n        };\n\n        /**\n         * Creates an EmptyRequest message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Protocol.EmptyRequest} EmptyRequest\n         */\n        EmptyRequest.fromObject = function fromObject(object) {\n            if (object instanceof $root.Protocol.EmptyRequest)\n                return object;\n            return new $root.Protocol.EmptyRequest();\n        };\n\n        /**\n         * Creates a plain object from an EmptyRequest message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Protocol.EmptyRequest\n         * @static\n         * @param {Protocol.EmptyRequest} message EmptyRequest\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        EmptyRequest.toObject = function toObject() {\n            return {};\n        };\n\n        /**\n         * Converts this EmptyRequest to JSON.\n         * @function toJSON\n         * @memberof Protocol.EmptyRequest\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        EmptyRequest.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EmptyRequest;\n    })();\n\n    Protocol.ToServerMsg = (function() {\n\n        /**\n         * Constructs a new ToServerMsg service.\n         * @memberof Protocol\n         * @classdesc Represents a ToServerMsg\n         * @extends $protobuf.rpc.Service\n         * @constructor\n         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n         */\n        function ToServerMsg(rpcImpl, requestDelimited, responseDelimited) {\n            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n        }\n\n        (ToServerMsg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ToServerMsg;\n\n        /**\n         * Creates new ToServerMsg service using the specified rpc implementation.\n         * @function create\n         * @memberof Protocol.ToServerMsg\n         * @static\n         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n         * @returns {ToServerMsg} RPC service. Useful where requests and/or responses are streamed.\n         */\n        ToServerMsg.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n            return new this(rpcImpl, requestDelimited, responseDelimited);\n        };\n\n        /**\n         * Callback as used by {@link Protocol.ToServerMsg#sendMsg}.\n         * @memberof Protocol.ToServerMsg\n         * @typedef SendMsgCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {Protocol.ACKResponse} [response] ACKResponse\n         */\n\n        /**\n         * Calls SendMsg.\n         * @function sendMsg\n         * @memberof Protocol.ToServerMsg\n         * @instance\n         * @param {Protocol.IMessageRequest} request MessageRequest message or plain object\n         * @param {Protocol.ToServerMsg.SendMsgCallback} callback Node-style callback called with the error, if any, and ACKResponse\n         * @returns {undefined}\n         * @variation 1\n         */\n        Object.defineProperty(ToServerMsg.prototype.sendMsg = function sendMsg(request, callback) {\n            return this.rpcCall(sendMsg, $root.Protocol.MessageRequest, $root.Protocol.ACKResponse, request, callback);\n        }, \"name\", { value: \"SendMsg\" });\n\n        /**\n         * Calls SendMsg.\n         * @function sendMsg\n         * @memberof Protocol.ToServerMsg\n         * @instance\n         * @param {Protocol.IMessageRequest} request MessageRequest message or plain object\n         * @returns {Promise<Protocol.ACKResponse>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link Protocol.ToServerMsg#responseToGate}.\n         * @memberof Protocol.ToServerMsg\n         * @typedef ResponseToGateCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {Protocol.MessageResponse} [response] MessageResponse\n         */\n\n        /**\n         * Calls ResponseToGate.\n         * @function responseToGate\n         * @memberof Protocol.ToServerMsg\n         * @instance\n         * @param {Protocol.IEmptyRequest} request EmptyRequest message or plain object\n         * @param {Protocol.ToServerMsg.ResponseToGateCallback} callback Node-style callback called with the error, if any, and MessageResponse\n         * @returns {undefined}\n         * @variation 1\n         */\n        Object.defineProperty(ToServerMsg.prototype.responseToGate = function responseToGate(request, callback) {\n            return this.rpcCall(responseToGate, $root.Protocol.EmptyRequest, $root.Protocol.MessageResponse, request, callback);\n        }, \"name\", { value: \"ResponseToGate\" });\n\n        /**\n         * Calls ResponseToGate.\n         * @function responseToGate\n         * @memberof Protocol.ToServerMsg\n         * @instance\n         * @param {Protocol.IEmptyRequest} request EmptyRequest message or plain object\n         * @returns {Promise<Protocol.MessageResponse>} Promise\n         * @variation 2\n         */\n\n        return ToServerMsg;\n    })();\n\n    return Protocol;\n})();\n\nmodule.exports = $root;\n","module.exports = \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3NpZ251cC9zaWdudXAuY29tcG9uZW50LmNzcyJ9 */\"","module.exports = \"\\n<div style=\\\"margin-left:100px\\\">\\n    <h1>注册</h1>\\n    <div>.</div>\\n  Username:<input nz-input placeholder=\\\"default size\\\" [(ngModel)]=\\\"name\\\" style=\\\"width: 200px\\\">\\n  <div>.</div>\\n  Password:<input nz-input placeholder=\\\"default size\\\" [(ngModel)]=\\\"password\\\" style=\\\"width: 200px\\\">\\n  <div>.</div>\\n  <button (click)=\\\"signup()\\\" nz-button nzType=\\\"primary\\\">提交</button>\\n</div>\\n\"","import { Component, OnInit } from '@angular/core';\nimport { LoginService  } from '../login.service';\n\n@Component({\n  selector: 'app-signup',\n  templateUrl: './signup.component.html',\n  styleUrls: ['./signup.component.css']\n})\nexport class SignupComponent implements OnInit {\n\n  constructor(private login: LoginService) { }\n\n\n  ngOnInit() {\n  }\n  name =''\n  password = ''\n\n  signup(){\n      let body = {name:this.name,password:this.password}\n      this.login.postSignupData(body).subscribe(data =>{\n        console.log(data);\n      })\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Protocol } from \"./protocol/Protocol\";\n\n@Injectable()\nexport class WebsocketService {\n\n  ws: WebSocket;\n  collection: Protocol.MessageRequest = new(Protocol.MessageRequest);\n  constructor() { }\n\n  createSocket(url:string){\n    this.ws = new WebSocket(url);\n\n    this.ws.onopen = function() {\n      console.log(\"流打开\")\n    };\n\n    this.ws.onmessage = function(evt) {\n      let reader = new FileReader();\n      reader.readAsArrayBuffer(evt.data);\n      reader.onload = function (e) {\n      let buf = new Uint8Array(reader.result as ArrayBuffer);\n      let conn = Protocol.MessageResponse.decode(buf);\n      console.log(conn)}\n      \n    };\n\n    this.ws.onclose = function() {\n      console.log(\"流结束\")\n    };\n  }\n\n  test(){\n    let msg = new(Protocol.MessageResponse)\n    msg.content = \"testing websocket protocol buf\"\n    msg.msgid = 28;\n    \n    this.ws.send(Protocol.MessageRequest.encode(msg).finish())\n  }\n  sendMessage(message: any){\n    this.ws.send(message);\n  }\n}\n","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n","import 'hammerjs';\nimport { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n"],"sourceRoot":""}